#include <machine.h>
#include <stdint.h>
#include "iodefine.h"
#include "KEYMATRIX_Driver.h"
#include "KEYMATRIX_HAL.h"

const char bitpos_decoder[16] = 
{
0xEE,0x00,0x01,0xFF,0x02,0xFF,0xFF,0xFF,
0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF
};
const char line_decoder[] = {0x10,0x20,0x40,0x80};
key_callback_t key_default_callback = key_default_callback_nop;
key_callback_t key_double_callback = key_default_callback_double;
key_t phy_key[16] 
= {
/* column 1 */
{0xC,},
{0xD,},
{0xE,},
{0xF,},
/* column 2 */
{8,},
{9,},
{0xA,},
{0xB,},
/* column 3 */
{4,},
{5,},
{6,},
{7,},
/* column 4 */
{0,},
{1,},
{2,},
{3,}}
;

void KEYMATRIX_Init(void){
	PORT6.DR.BYTE	= 0xFF;
	PORT6.DDR.BYTE	= 0x00;
	PORT6.ICR.BYTE  = LINE_DIRECT_DEFINE^0xFF;
#if KEYMATRIX_USE_TIMER
	/***** CMTチャネル0の初期化 *****/
    MSTP(CMT1) = 0;                        /* CMTユニット0(CMT0チャネル)モジュールストップを解除 */
    CMT1.CMCOR =(unsigned short )( (48000000.0 / 128.0 / 50 ) - 1);                           /* CMT0.CMCORにコンペアマッチ周期を設定(1ms) */
    CMT1.CMCR.WORD = 0x00C2;                           /* 周辺クロックPCLK=48MHzの128分周を設定, */
    CMT.CMSTR0.BIT.STR1 = 1;
         
    IR ( CMT1,CMI1 ) = 0;
	#if KEY_INTERRUPT
    IEN( CMT1,CMI1 ) = 1;
	#endif
    IPR( CMT1,CMI1 ) = 1;
#endif
}
void KEYMATRIX_RegistCallback(key_t *pkey, key_callback_t func){
	if( pkey ){
		pkey->key_callback = func;
	}
}

void key_default_callback_nop( key_event_t event, void *pkey){
	nop();
}
void key_default_callback_double( key_event_t event, void *pkey){
	nop();
}

#if KEY_INTERRUPT
#pragma interrupt cmt1_cmi1_handler(vect = VECT(CMT1,CMI1))
#endif

void KEYMATRIX_Polling(void){
	static int	i,bitpos,bitpos_temp;
	static char input_row,lock = 0;

	static uint16_t last_pattern_count = 0;
	static uint32_t last_pattern = 0xFFFFFFFF;
	static uint32_t pattern = 0xFFFFFFFF;
	static uint16_t pressed_key_counter = 0;
	
	
	bitpos = 0xFF;
	pattern = 0;
	for( i = 0; i < 4 ; i++ ){
		SET_SCAN_LINE(i);
		input_row = GET_DATA_4BIT() ^ 0xF;
		pattern |= input_row << ( i * 4 );
		
	}
	
	if( pattern == 0x00000000 ){
		if( last_pattern != 0x00000000 ){
			if( !lock ){
				/* KEY_UP*/
				pressed_key_counter = 0;
				for( i = 0;i < 4; i++ ){
					bitpos_temp = (i<<2) | bitpos_decoder[((last_pattern>>(i*4)) & 0xF)];
					if( bitpos_temp == 0xFF ){
						pressed_key_counter = 2;					
					}else if( bitpos_temp != 0xEE){
						bitpos = bitpos_temp;
						pressed_key_counter ++;
					}
				}
				/* multi-key exception */
				if( pressed_key_counter > 1 ){
					key_double_callback( KEY_UP, (void*)last_pattern );
				}else{
					if( phy_key[bitpos].key_callback == 0  ){
						key_default_callback( KEY_UP, &phy_key[bitpos]);
					}else{
						phy_key[bitpos].key_callback( KEY_UP, &phy_key[bitpos]);
					}
				}
			}
			lock = 0;
	
		}
	}
	/* if any key pressed */
	else if( last_pattern == pattern ){
		last_pattern_count++;
		if( last_pattern_count == KEY_CNT_TH ){
			/* key down */
			/* calculate which key pressed */
			pressed_key_counter = 0;
			for( i = 0;i < 4; i++ ){
				bitpos_temp = (i<<2) | bitpos_decoder[((last_pattern>>(i*4)) & 0xF)];
				if( bitpos_temp == 0xFF ){
					pressed_key_counter = 2;					
				}else if( bitpos_temp != 0xEE){
					bitpos = bitpos_temp;
					pressed_key_counter ++;
				}
			}
			/* multi-key exception */
			if( pressed_key_counter > 1 ){
				key_double_callback( KEY_DOWN, (void*)last_pattern );
				lock = 1;
			}else{
				if( !lock ){
					if( phy_key[bitpos].key_callback == 0  ){
						key_default_callback( KEY_DOWN, &phy_key[bitpos]);
					}else{
						phy_key[bitpos].key_callback( KEY_DOWN, &phy_key[bitpos]);
					}
				}
			}
		}else if(  last_pattern_count >= KEY_CNT_TH ){
			/* key hold */
			nop();
		}	
	
	}else if( last_pattern != pattern ){
		
		last_pattern_count = 0;
		/* pressed key changed*/
	}
	last_pattern = pattern;
}


